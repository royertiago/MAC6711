\section{Aplicação: Treaps}
\label{sec:treaps}

De acordo com o Teorema~\ref{thm:average-tree-depth},
uma árvore de busca gerada aleatoriamente
possui altura esperada logarítmica.
Mais especificamente,
uma árvore de $n$ nós
deve ter profundidade pouco inferior a $3 \log_2 n$.
Árvores autobalanceadas,
como AVL e rubro-negras,
possuem profundidade inferior a $1.441 \log_2 n$ \cite[p.~460]{Knuth1998}
e $2 \log_2 n$ \cite[p.~309]{CormenLeisersonRivestStein2009},
respectivamente.
Portanto,
na média,
árvores binárias de busca geradas aleatoriamente
possuem profundidade similar às árvores autobalanceadas,
mas sem o overhead de fazer o balanceamento.

Entretanto,
tipicamente, ocorrem inserções e remoções de maneira desordenada na árvore.
Assim,
não basta permutar os nós aleatoriamente apenas uma vez,
pois a árvore e os elementos variam ao longo da execução do programa.
Sabe-se muito pouco sobre o comportamento de árvores binárias de busca
quando inserções e remoções são intercaladas%
~\cite[p.~300]{CormenLeisersonRivestStein2009},
portanto é necessário cuidado ao alterar uma árvore gerada aleatoriamente
para que sua ``aleatoriedade'' se mantenha,
o que nos permite analisá-la.

Treaps
(introduzidas por Aragon e Seidel~\cite{AragonSeidel1989})
são uma forma de preservar a aleatoriedade.
A ideia é associar cada elemento a uma prioridade aleatória,
e permutar o vetor de acordo com essa prioridade.
Como a inserção/remoção de elementos
não altera a distribuição de prioridades,
a árvore continuará sendo uma árvore binária de busca aleatória,
preservando a profundidade esperada logarítmica.

Para definir treaps, precisamos do conceito de \emph{heap}.

\begin{definition}
    Uma árvore binária em que todos os nós possuem uma prioridade associada
    é um \emph{heap}
    se todos os nós da árvore tiverem prioridade maior do que seus filhos.
\end{definition}

É importante notar que há um conceito alternativo de heap na literatura;
em textos como o livro de Cormen et. al.~\cite[p.~152]{CormenLeisersonRivestStein2009},
um heap, além de satisfazer a exigência acima,
ainda precisa ser uma árvore binária completa ou quase completa
--- isto é, todos os níveis precisam estar completos,
com exceção do último, que pode estar incompleto,
mas precisa ser preenchido da esquerda para a direita.
Esta restrição adicional
faz com que heaps possam ser eficientemente implementadas como um vetor,
tanto acelerando acesso e modificação quanto reduzindo o espaço utilizado.
(Note que todas essas otimizações apenas mexem na constante associada.)
Alguns textos, como o livro de Sedgewick e Flajolet~\cite[p.~362]{SedgewickFlajolet2013},
chamam a condição acima de ``ordem de heap'';
então, o que eles chamam de ``árvore em ordem de heap``,
nós chamaremos simplesmente de ``heap''.

A Figura~\ref{fig:heap} contêm um exemplo de heap.
\begin{figure}[h]
    \centering
    \begin{tikzpicture}[binary tree layout, nodes={circle, draw}]
        \node {8}
        child { node {4}
            child { node {2} }
            child { node {3} }
        }
        child { node {7}
            child[missing]
            child { node {6}
                child { node {1} }
                child { node {5} }
            }
        };
    \end{tikzpicture}
    \caption{Heap correspondente à permutação $(2, 4, 3, 8, 7, 1, 6, 5)$.}
    \label{fig:heap}
\end{figure}
É interessante notar que existe uma bijeção simples entre
permutações de $n$ elementos e heaps construídas com os números $\{1, \dots, n\}$.
Dada um heap, para construir a permutação correspondente,
basta percorrer os nós em ordem simétrica (in-order).
Para reconstruir o heap a partir da permutação,
tome $k$ como sendo o índice do maior elemento e coloque-o como raiz;
construa a subárvore esquerda recursivamente
usando os elementos nas posições $1, \dots, k-1$,
e a subárvore direita usando os elemento nas posições $k+1, \dots, n$.
Isso mostra que existem $n!$ heaps sobre um conjunto de elementos distintos.

De posse da definição de heap,
podemos definir treap.

\begin{definition}
    Uma árvore binária cujos nós possuem tanto chaves quanto prioridades associadas
    é uma \emph{treap}
    se for simultaneamente uma árvore de busca de acordo com as chaves
    e um heap de acordo com as prioridades.
\end{definition}

As prioridades serão escolhidas aleatoriamente.

Treaps são, portanto, árvores-heap.
As chaves impõem a ordem dos nós;
como existem $C_n$ diferentes árvores de busca possíveis para a mesma ordem,
as prioridades aleatórias forçam a escolha de uma destas árvores.
Dado um conjunto $X = \{ (k_i, p_i) \mid 1 \leq i \leq n) \}$,
se todas as prioridades forem distintas,
existe uma única treap que contém os elementos deste conjunto.
Para construí-la,
observe que a raiz da árvore necessariamente será o elemento de maior prioridade.
Depois de fixada a raiz,
a exigência do ordenamento determina quais nós ficarão na subárvore esquerda
e quais ficarão na subárvore direita.
Repita esta construção em cada subárvore;
por indução, existe uma única treap em cada caso,
o que garante a existência e unicidade da árvore atual.

Alternativamente,
podemos construir uma árvore binária de busca
inserindo os nós em ordem decrescente de prioridade.
A construção padrão sempre adiciona um novo nó como uma folha,
portanto teremos um heap;
e a ordem é garantida pelo próprio algoritmo.

Este é o ``truque'' das treaps:
ao escolher aleatoriamente uma prioridade para cada elemento,
estamos, efetivamente,
permutando os elementos e então inserindo-os na árvore.
Conforme analisado no Teorema~\ref{thm:shuffle-by-sorting},
todas as permutações dos elementos são equiprováveis.
Portanto,
as árvores binárias de busca geradas
seguem a distribuição analisada no Teorema~\ref{thm:average-tree-depth};
assim,
sabemos que a profundidade média das treaps será $3 \log_2 n$.

Operações como inserir e remover elementos
podem ser entendidos como apenas alterando o conjunto de elementos $X$;
como a treap é única e as prioridades são aleatórias,
inserção e remoção alteram diretamente a permutação subjacente,
mantendo a profundidade esperada em $3 \log_2 n$.
(Observe que a inserção de um novo elemento
exige a geração de uma nova prioridade aleatória.)

\subsection{Inserção e remoção}
Esta seção descreve uma implementação de inserção e remoção de valores numa treap.
Os algoritmos estão em pseudocódigo;
uma versão em \verb"C++" está disponível em
\verb"github.com/royertiago/MAC6711".
Estes algoritmos foram baseados no artigo de Seidel e Aragon~%
\cite[p.~450]{SeidelAragon1996},
que contém uma discussão mais completa sobre aspectos práticos da implementação de treaps.

Ignoraremos tanto a etapa da geração aleatória de prioridades
quanto casos de uso como mapeamentos e filas de prioridade;
portanto,
o nó da treap contém quatro membros:
uma chave, uma prioridade,
e dois ponteiros para as subárvores.

Assumiremos, nesta seção,
que a passagem de parâmetros ocorre por referência.

Em ambos os casos,
trabalharemos recursivamente.
Para a inserção,
após inserir o novo elemento na subárvore esquerda (digamos),
pode ser que a raiz da subárvore esquerda
tenha ficado com prioridade maior do que o nó atual.
Neste caso,
rotacionando o nó atual para a direita promove o outro nó a raiz,
sem alterar a ordem das chaves
(que é preservada pela rotação)
nem das prioridades
(pois apenas um novo nó foi inserido na subárvore esquerda).
A inserção na subárvore direita é simétrica.

\begin{codebox}
    \Procname{$\proc{Treap-Insert}(T, \id{key}, \id{priority})$}
    \li \If $T == \id{null}$
    \li \Then
            $T \gets \proc{New-Node(\id{key}, \id{priority})}$
    \li \ElseIf $\id{key} < \attrib{T}{key}$
    \li \Then
            $\proc{Treap-Insert}(\attrib{T}{lchild}, \id{key}, \id{priority})$
    \li     \If $\attribb{T}{lchild}{priority} > \attrib{T}{priority}$
    \li         \Then $\proc{Rotate-Right}(T)$
            \End
    \li \ElseIf $\attrib{T}{key} < \id{key}$
    \li \Then
            $\proc{Treap-Insert}(\attrib{T}{rchild}, \id{key}, \id{priority})$
    \li     \If $\attribb{T}{rchild}{priority} > \attrib{T}{priority}$
    \li         \Then $\proc{Rotate-Left}(T)$
            \End
    \li \ElseNoIf
    \li     \Comment A chave já aparece na árvore.
        \End
\end{codebox}

Para a remoção,
faremos em duas partes:
primeiro, localizar a subárvore na treap
que possui o elemento a ser removido como raiz.

\begin{codebox}
    \Procname{$\proc{Treap-Remove}(T, \id{key})$}
    \li \If $T == \id{null}$
    \li \Then \Comment Elemento não aparece na árvore.
    \li \ElseIf $\id{key} < \attrib{T}{key}$
    \li \Then $\proc{Treap-Remove}(\attrib{T}{lchild}, \id{key})$
    \li \ElseIf $\attrib{T}{key} < \id{key}$
    \li \Then $\proc{Treap-Remove}(\attrib{T}{rchild}, \id{key})$
    \li \ElseNoIf
    \li     $\proc{Root-Remove}(T)$
        \End
\end{codebox}

E, agora, excluiremos a raiz desta subárvore.
Se algum dos nós filhos da raiz não estiver presente,
basta substituí-lo pelo outro nó (que pode ser nulo);
caso contrário,
rotacionaremos a raiz para baixo
e chamaremos o procedimento recursivamente.
Em algum momento,
o nó a ser removido se tornará folha,
caindo no caso anterior.

\begin{codebox}
    \Procname{$\proc{Root-Remove}(T)$}
    \li \If $\attrib{T}{lchild} == \id{null}$
    \li \Then $T \gets \attrib{T}{rchild}$
    \li \ElseIf $\attrib{T}{rchild} == \id{null}$
    \li \Then $T \gets \attrib{T}{lchild}$
    \li \ElseIf $\attribb{T}{lchild}{priority} < \attribb{T}{rchild}{priority}$
    \li \Then
            $\proc{Rotate-Left}(T)$
    \li     $\proc{Root-Remove}(\attrib{T}{lchild})$
    \li \ElseNoIf
    \li     $\proc{Rotate-Right}(T)$
    \li     $\proc{Root-Remove}(\attrib{T}{rchild})$
        \End
\end{codebox}
